
/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model where user-generated content is stored
 * in publicly readable collections but write access is restricted to the owner. It provides a clear separation
 * between private user data and globally accessible public data. The primary goal is strong authorization while
 * maintaining flexibility for viral sharing and deep-linking.
 *
 * Data Structure:
 * - `/users/{userId}`: Acts as the root for all data private to a specific user, like their profile.
 * - `/sharing_cards/{cardId}`: A public collection of all sharing cards. Anyone can read, but only the owner can write.
 * - Public assets (`satire_assets`, `buzzword_definitions`, `class_archetypes`) are top-level, read-only collections.
 *
 * Key Security Decisions:
 * - User Isolation: A user can only manage data within their own `/users/{userId}` path and write to documents they own.
 * - No User Enumeration: Listing documents in the top-level `/users` collection is forbidden.
 * - Public Data is Read-Only: Collections like `satire_assets`, `buzzword_definitions`, and `class_archetypes` are readable by anyone
 *   but are not writable by clients. This is the most secure posture, assuming an admin or backend process manages this content.
 * - Viral Sharing Support: The `/sharing_cards` collection is publicly readable, allowing anyone with a link to view a card.
 *   This is essential for social sharing and deep-linking.
 * - Default Secure: Any path not explicitly matched is denied access. All write operations require authentication.
 *
 * Denormalization for Authorization: The `SharingCard` documents contain a denormalized `userProfileId` field. This allows
 * security rules to validate ownership on create, update, and delete operations without needing a costly `get()` call
 * to another document, leading to simpler and more performant rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the fundamental check for resource ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Checks for ownership on an existing resource for read operations.
     */
    function isResourceOwner(resource) {
        return isSignedIn() && request.auth.uid == resource.data.userProfileId;
    }
    
    /**
     * Checks if the incoming data only contains the allowed fields for submission.
     */
     function isSubmittingForFeature() {
       let incomingKeys = request.resource.data.keys();
       let allowedKeys = ['inspirationalStory', 'submissionStatus'];
       // Ensure only allowed fields are being updated
       return incomingKeys.hasOnly(allowedKeys) &&
              request.resource.data.submissionStatus == 'pending';
     }


    // ----------------------------------------------------------------------
    // User-Private Data
    // ----------------------------------------------------------------------

    /**
     * @description Secures a user's own profile document.
     * @path /users/{userId}
     * @allow (create) An authenticated user creating their own profile document for the first time.
     * @allow (get, update, delete) An authenticated user managing their own profile document.
     * @deny (list) Any user attempting to list all user profiles.
     * @deny (get) An authenticated user attempting to read another user's profile.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isOwner(userId);

        // DEPRECATED: Sub-collections for sharing cards are no longer used.
        // This is kept to deny any accidental writes to the old path.
        match /sharing_cards/{sharingCardId} {
            allow read, write: if false;
        }
    }

    // ----------------------------------------------------------------------
    // Public Sharing & User-Owned Content
    // ----------------------------------------------------------------------

    /**
     * @description Secures sharing cards in a public collection.
     * @path /sharing_cards/{sharingCardId}
     * @allow (get, list) Any user, authenticated or not, can read any card for viral sharing.
     * @allow (create) An authenticated user creating a card, as long as they set themselves as the owner.
     * @allow (update) The card owner can submit for feature, or an admin can manage status. (Client-side logic only handles submission)
     * @allow (delete) Only the user who created the card can delete it.
     * @principle Enables public deep-linking while restricting writes to the resource owner.
     */
    match /sharing_cards/{sharingCardId} {
      allow get: if true;
      allow list: if true; // Allows for leaderboards/galleries
      allow create: if isOwner(request.resource.data.userProfileId);
      allow update: if isResourceOwner(resource) && (
        isSubmittingForFeature() || request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewCount'])
      );
      allow delete: if isResourceOwner(resource);
    }
    
    /**
     * @description Secures marketplace links, which are nested under a user's sharing card.
     * @path /sharing_cards/{sharingCardId}/marketplace_links/{marketplaceLinkId}
     * @allow (get, list) Anyone can read the marketplace links.
     * @allow (create, update, delete) Only the card owner can manage associated links.
     * @principle Inherits ownership from the parent path, ensuring only the card owner can manage associated links.
     */
    match /sharing_cards/{sharingCardId}/marketplace_links/{marketplaceLinkId} {
      allow get: if true;
      allow list: if true;
      allow create: if isOwner(get(/databases/$(database)/documents/sharing_cards/$(sharingCardId)).data.userProfileId);
      allow update: if isOwner(resource.data.userProfileId);
      allow delete: if isOwner(resource.data.userProfileId);
    }


    // ----------------------------------------------------------------------
    // Public Read-Only Data
    // ----------------------------------------------------------------------

    /**
     * @description Allows public read access to satirical wit presets. Writes are disabled.
     * @path /satire_assets/{satireAssetId}
     * @allow (get, list) Any user, including unauthenticated ones, reading preset data.
     * @deny (create, update, delete) Any user attempting to modify the global presets.
     * @principle Secures global, read-only content. Assumes this data is managed by an admin via the console or a trusted backend.
     */
    match /satire_assets/{satireAssetId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to buzzword definitions. Writes are disabled.
     * @path /buzzword_definitions/{definitionId}
     * @allow (get, list) Any user, including unauthenticated ones, reading buzzword definitions.
     * @deny (create, update, delete) Any user attempting to modify the global definitions.
     * @principle Secures global, read-only content. Assumes this data is managed by an admin via the console or a trusted backend.
     */
    match /buzzword_definitions/{definitionId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to class archetypes. Writes are disabled.
     * @path /class_archetypes/{classArchetypeId}
     * @allow (get, list) Any user, including unauthenticated ones, reading class archetype data.
     * @deny (create, update, delete) Any user attempting to modify the global class archetypes.
     * @principle Secures global, read-only content. Assumes this data is managed by an admin via the console or a trusted backend.
     */
    match /class_archetypes/{classArchetypeId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}
